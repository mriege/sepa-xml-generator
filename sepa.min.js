/**
 * SEPA.js - SEPA XML Document Generator Library
 *
 * Erzeugt ISO 20022 konforme XML-Dokumente fuer SEPA-Lastschriften (pain.008)
 * und SEPA-Ueberweisungen (pain.001).
 *
 * Architektur:
 *   Document (h)        - Hauptdokument, enthaelt GroupHeader und PaymentInfos
 *   GroupHeader (m)     - Kopfdaten: Ersteller, Erstellungszeitpunkt, Kontrollsumme
 *   PaymentInfo (p)     - Zahlungsblock: Glaeubigeor/Schuldner-Daten, Einstellungen
 *   Transaction (y)     - Einzelne Transaktion: Empfaenger, Betrag, Verwendungszweck
 *
 * Unterstuetzte Formate:
 *   pain.001.001.03 / .08 / .09  - SEPA-Ueberweisung (Credit Transfer)
 *   pain.008.001.02 / .08        - SEPA-Lastschrift (Direct Debit)
 *
 * Verwendung:
 *   var doc = new SEPA.Document("pain.001.001.09");
 *   doc.grpHdr.id = "MSG-001";
 *   doc.grpHdr.created = new Date();
 *   doc.grpHdr.initiatorName = "Firma GmbH";
 *   var info = doc.createPaymentInfo();
 *   // ... info konfigurieren, Transaktionen hinzufuegen ...
 *   doc.addPaymentInfo(info);
 *   var xml = doc.toString();
 *
 * UMD-Modul: Im Browser als window.SEPA, in Node.js als exports verfuegbar.
 *
 * @license Open Source
 * @see ISO 20022 - https://www.iso20022.org/
 */
(function (t) {
  // ============================================================
  // Konstanten fuer die XML-Dokumenterzeugung
  // ============================================================

  /** XML-Namespace fuer Schema-Instanz (xsi) - wird im Root-Element referenziert */
  var a = "http://www.w3.org/2001/XMLSchema-instance";

  /** Basis-Namespace fuer ISO 20022 pain-Formate (wird mit konkretem Format ergaenzt) */
  var s = "urn:iso:std:iso:20022:tech:xsd:";

  /** XML-Version fuer den XML-Header (<?xml version="1.0" ...?>) */
  var n = "1.0";

  /** XML-Encoding fuer den XML-Header */
  var e = "UTF-8";

  /** Standard pain-Format, wenn keines angegeben wird */
  var r = "pain.008.001.02";

  /**
   * Trennzeichen fuer zusammengesetzte IDs (z.B. "MSG-001.0.0" fuer PaymentInfo.Transaction)
   * Kann ueber SEPA.setIDSeparator() geaendert werden
   */
  var i = ".";

  /**
   * Setzt das Trennzeichen fuer die automatische ID-Generierung.
   * Standardmaessig wird "." verwendet (z.B. PaymentInfo-ID = "MSG-001.0").
   * @param {string} t - Neues Trennzeichen
   */
  function o(t) {
    i = t
  }

  /**
   * Flag ob Validierungen aktiv sind (Standard: true).
   * Kann ueber SEPA.enableValidations(false) deaktiviert werden.
   */
  var c = true;

  /**
   * Aktiviert oder deaktiviert die Validierung aller Felder vor der XML-Erzeugung.
   * @param {boolean} t - true = Validierungen aktiv, false = deaktiviert
   */
  function d(t) {
    c = !!t
  }

  // ============================================================
  // Pain-Format-Mapping: Format-String → XML-Root-Element-Name
  // ============================================================
  //
  // Jedes SEPA pain-Format hat ein spezifisches Root-Element im XML:
  //   - CstmrCdtTrfInitn = Customer Credit Transfer Initiation (Ueberweisung)
  //   - CstmrDrctDbtInitn = Customer Direct Debit Initiation (Lastschrift)
  //
  // Aeltere Formate (Version 01/02 ohne "Cstmr"-Prefix) verwenden den
  // Format-String direkt als Root-Element-Name.
  var u = {
    /** pain.001 = Ueberweisung (Credit Transfer) */
    "pain.001.001.02": "pain.001.001.02",       // Alte Version - Root = Format-String
    "pain.001.003.02": "pain.001.003.02",       // Alte Version (DK-Variante)
    "pain.001.001.03": "CstmrCdtTrfInitn",     // Standard-Version 03
    "pain.001.003.03": "CstmrCdtTrfInitn",     // DK-Variante Version 03
    "pain.001.001.08": "CstmrCdtTrfInitn",     // Neuere Version 08
    "pain.001.001.09": "CstmrCdtTrfInitn",     // Neueste Version 09 (empfohlen)

    /** pain.008 = Lastschrift (Direct Debit) */
    "pain.008.001.01": "pain.008.001.01",       // Alte Version - Root = Format-String
    "pain.008.003.01": "pain.008.003.01",       // Alte Version (DK-Variante)
    "pain.008.001.02": "CstmrDrctDbtInitn",    // Standard-Version 02
    "pain.008.003.02": "CstmrDrctDbtInitn",    // DK-Variante Version 02
    "pain.008.001.08": "CstmrDrctDbtInitn"     // Aktuelle Version 08 (empfohlen)
  };

  /**
   * Ermittelt die Schema-Version eines pain-Formats als Zahl.
   * Wird verwendet, um versionsspezifische XML-Elemente einzufuegen oder wegzulassen.
   *
   * Berechnung: Letzte 2 Ziffern des Format-Strings + 1 fuer Lastschriften.
   * Ergebnis:
   *   Version 2 = Aeltere Formate (mit BatchBooking und Grouping im GroupHeader)
   *   Version 3 = Neuere Formate (mit BatchBooking, NbOfTxs und CtrlSum in PaymentInfo)
   *
   * @param {string} t - Pain-Format-String (z.B. "pain.001.001.09")
   * @returns {number} Schema-Version (2 oder 3)
   */
  function l(t) {
    var n = t.indexOf("pain.008") === 0 ? 1 : 0;
    return parseInt(t.substr(-2), 10) + n
  }

  // ============================================================
  // Document-Klasse (h) - SEPA XML-Hauptdokument
  // ============================================================

  /**
   * Erstellt ein neues SEPA-Dokument.
   * Das Dokument ist der aeusserste Container und enthaelt:
   *   - Einen GroupHeader (grpHdr) mit Metadaten
   *   - Eine oder mehrere PaymentInfos mit den eigentlichen Zahlungsdaten
   *
   * @constructor
   * @param {string} [t="pain.008.001.02"] - Pain-Format (z.B. "pain.001.001.09")
   */
  function h(t) {
    this._painFormat = t || r;
    this._type = u[this._painFormat];  // Root-Element-Name aus dem Mapping
    this._paymentInfo = [];             // Liste der PaymentInfo-Bloecke
    this._xmlVersion = n;
    this._xmlEncoding = e;
    this.grpHdr = new m(this._painFormat)  // GroupHeader automatisch erstellen
  }

  /** Statischer Zugriff auf das Format-Mapping */
  h.Types = u;

  h.prototype = {
    _painFormat: null,
    grpHdr: null,
    _paymentInfo: [],
    _type: null,
    _xmlVersion: null,
    _xmlEncoding: null,

    /**
     * Fuegt einen PaymentInfo-Block zum Dokument hinzu.
     * Die ID des PaymentInfo-Blocks wird automatisch mit der Dokument-ID prefixed:
     *   Format: "{grpHdr.id}.{paymentInfo.id}" oder "{grpHdr.id}.{laufende_nummer}"
     *
     * @param {Object} t - PaymentInfo-Objekt (erstellt via createPaymentInfo())
     */
    addPaymentInfo: function (t) {
      // Hinweis: instanceof-Pruefung wurde entfernt, um Kompatibilitaet mit
      // verschiedenen Ausfuehrungskontexten (iframes, Module) sicherzustellen
      if (t.id) {
        t.id = this.grpHdr.id + i + t.id
      } else {
        t.id = this.grpHdr.id + i + this._paymentInfo.length
      }
      this._paymentInfo.push(t)
    },

    /**
     * Erstellt einen neuen PaymentInfo-Block mit dem pain-Format des Dokuments.
     * Der Block muss nach Konfiguration ueber addPaymentInfo() hinzugefuegt werden.
     *
     * @returns {Object} Neues PaymentInfo-Objekt
     */
    createPaymentInfo: function () {
      return new p(this._painFormat)
    },

    /**
     * Normalisiert das Dokument: Berechnet Kontrollsummen und Transaktionszaehler.
     * Wird automatisch vor der XML-Erzeugung (toXML) aufgerufen.
     *
     * Aggregiert ueber alle PaymentInfos:
     *   - controlSum: Gesamtbetrag aller Transaktionen
     *   - transactionCount: Gesamtanzahl aller Transaktionen
     */
    normalize: function () {
      var t = 0;  // Gesamtbetrag
      var n = 0;  // Gesamtanzahl Transaktionen
      for (var e = 0, r = this._paymentInfo.length; e < r; ++e) {
        this._paymentInfo[e].normalize();
        t += this._paymentInfo[e].controlSum;
        n += this._paymentInfo[e].transactionCount
      }
      this.grpHdr.controlSum = t;
      this.grpHdr.transactionCount = n
    },

    /**
     * Erzeugt das komplette XML-Dokument als DOM-Objekt.
     *
     * XML-Struktur:
     *   <?xml version="1.0" encoding="UTF-8"?>
     *   <Document xmlns="urn:iso:std:iso:20022:tech:xsd:{painFormat}"
     *             xmlns:xsi="..." xsi:schemaLocation="...">
     *     <CstmrCdtTrfInitn>  (oder CstmrDrctDbtInitn)
     *       <GrpHdr>...</GrpHdr>
     *       <PmtInf>...</PmtInf>
     *       ...weitere PmtInf...
     *     </CstmrCdtTrfInitn>
     *   </Document>
     *
     * @returns {Document} XML DOM-Dokument
     */
    toXML: function () {
      this.normalize();
      var t = s + this._painFormat;              // Vollstaendiger Namespace
      var n = O(t, "Document");                  // Neues XML-Dokument erstellen
      n.xmlVersion = this._xmlVersion;
      n.xmlEncoding = this._xmlEncoding;
      var e = n.documentElement;                 // <Document>-Element
      e.setAttribute("xmlns:xsi", a);
      e.setAttribute("xsi:schemaLocation", s + this._painFormat + " " + this._painFormat + ".xsd");
      var r = n.createElementNS(t, this._type);  // Root-Element (z.B. CstmrCdtTrfInitn)
      r.appendChild(this.grpHdr.toXML(n));       // GroupHeader einfuegen
      for (var i = 0, o = this._paymentInfo.length; i < o; ++i) {
        r.appendChild(this._paymentInfo[i].toXML(n))  // Alle PaymentInfos einfuegen
      }
      n.documentElement.appendChild(r);
      return n
    },

    /**
     * Erzeugt das komplette XML-Dokument als String (mit XML-Header).
     * @returns {string} Vollstaendiger XML-String
     */
    toString: function () {
      var t = this.toXML();
      var n = '<?xml version="' + t.xmlVersion + '" encoding="' + t.xmlEncoding + '"?>';
      return n + L(t)
    }
  };

  // ============================================================
  // GroupHeader-Klasse (m) - XML <GrpHdr>-Element
  // ============================================================

  /**
   * GroupHeader enthaelt die Metadaten des SEPA-Dokuments:
   *   - MsgId: Eindeutige Nachrichtenkennung
   *   - CreDtTm: Erstellungszeitpunkt (ISO 8601)
   *   - NbOfTxs: Gesamtanzahl der Transaktionen
   *   - CtrlSum: Kontrollsumme (Gesamtbetrag)
   *   - InitgPty/Nm: Name des Initiators
   *
   * @constructor
   * @param {string} t - Pain-Format-String
   */
  function m(t) {
    this._painFormat = t
  }
  m.prototype = {
    _painFormat: null,
    id: "",                    // MsgId - Eindeutige Nachrichtenkennung
    created: "",               // CreDtTm - Erstellungszeitpunkt (muss Date-Objekt sein)
    transactionCount: 0,       // NbOfTxs - Gesamtanzahl Transaktionen
    initiatorName: "",         // InitgPty/Nm - Name des Erstellers
    controlSum: 0,             // CtrlSum - Gesamtbetrag aller Transaktionen
    batchBooking: false,       // BtchBookg - Sammelbuchung ja/nein (nur Version 2)
    grouping: "MIXD",          // Grpg - Gruppierungsmodus (nur Version 2)

    /**
     * Erzeugt das <GrpHdr> XML-Element.
     *
     * Versionsspezifische Elemente:
     *   Version 2 (aeltere Formate): Enthaelt BtchBookg und Grpg
     *   Version 3 (neuere Formate): Diese Felder fehlen im GrpHdr
     *
     * @param {Document} t - XML-Dokument fuer createElement-Aufrufe
     * @returns {Element} <GrpHdr> XML-Element
     */
    toXML: function (t) {
      var n = M(t, true, true);  // Helper: Element erstellen + Text setzen
      var e = t.createElementNS(t.documentElement.namespaceURI, "GrpHdr");
      var r = l(this._painFormat);  // Schema-Version ermitteln

      n(e, "MsgId", this.id);                              // Nachrichtenkennung
      n(e, "CreDtTm", this.created.toISOString());          // Erstellungszeitpunkt
      if (r === 2) {
        n(e, "BtchBookg", this.batchBooking.toString())     // Nur bei Version 2
      }
      n(e, "NbOfTxs", this.transactionCount);               // Anzahl Transaktionen
      n(e, "CtrlSum", this.controlSum.toFixed(2));           // Kontrollsumme (2 Dezimalen)
      if (r === 2) {
        n(e, "Grpg", this.grouping)                          // Nur bei Version 2
      }
      n(e, "InitgPty", "Nm", this.initiatorName);           // Initiator-Name (verschachtelt)
      return e
    },

    toString: function () {
      return L(this.toXML())
    }
  };

  // ============================================================
  // PaymentInfo-Typen (Zahlungsmethoden)
  // ============================================================

  /** Zahlungsmethoden-Konstanten fuer das <PmtMtd>-Element */
  var f = {
    DirectDebit: "DD",   // Lastschrift (Direct Debit)
    Transfer: "TRF"      // Ueberweisung (Credit Transfer)
  };

  // ============================================================
  // PaymentInfo-Klasse (p) - XML <PmtInf>-Element
  // ============================================================

  /**
   * PaymentInfo enthaelt einen Zahlungsblock mit Konfiguration und Transaktionen.
   * Jeder Block hat einen Glaeubigeor (bei Lastschrift) oder Schuldner (bei Ueberweisung)
   * und beliebig viele einzelne Transaktionen.
   *
   * XML-Struktur <PmtInf>:
   *   <PmtInfId>       - ID des Zahlungsblocks
   *   <PmtMtd>         - DD (Lastschrift) oder TRF (Ueberweisung)
   *   <PmtTpInf>       - Zahlungstyp-Informationen (SEPA, Sequenztyp, Instrumentierung)
   *   <ReqdColltnDt>   - Einzugsdatum (nur Lastschrift)
   *   <ReqdExctnDt>    - Ausfuehrungsdatum (nur Ueberweisung)
   *   <Cdtr/Dbtr>      - Glaeubigeor/Schuldner-Daten (Name, Adresse)
   *   <CdtrAcct/DbtrAcct> - Konto (IBAN)
   *   <CdtrAgt/DbtrAgt>   - Bank (BIC)
   *   <CdtrSchmeId>    - Glaeubigeor-Identifikation (nur Lastschrift)
   *   <DrctDbtTxInf>*  - Lastschrift-Transaktionen
   *   <CdtTrfTxInf>*   - Ueberweisungs-Transaktionen
   *
   * @constructor
   * @param {string} t - Pain-Format-String
   */
  function p(t) {
    this._painFormat = t;
    // Zahlungsmethode automatisch aus dem Format ableiten:
    // pain.001 = Ueberweisung, pain.008 = Lastschrift
    this.method = t.indexOf("pain.001") === 0 ? f.Transfer : f.DirectDebit;
    this._payments = []  // Liste der Transaktionen
  }

  /** Statischer Zugriff auf PaymentInfo-Typen */
  p.PaymentInfoTypes = f;

  p.prototype = {
    _painFormat: null,
    _payments: null,
    id: "",                            // PmtInfId - Zahlungsblock-ID
    method: null,                      // PmtMtd - DD oder TRF
    batchBooking: false,               // BtchBookg - Sammelbuchung
    grouping: "MIXD",                  // Gruppierung
    controlSum: 0,                     // CtrlSum - Betragssumme
    localInstrumentation: "CORE",      // LclInstrm/Cd - CORE, COR1 oder B2B
    sequenceType: "FRST",              // SeqTp - FRST, RCUR, OOFF oder FNAL
    collectionDate: null,              // ReqdColltnDt - Einzugsdatum (nur Lastschrift)
    requestedExecutionDate: null,      // ReqdExctnDt - Ausfuehrungsdatum (nur Ueberweisung)
    creditorId: "",                    // Glaeubigeor-ID (nur Lastschrift)
    creditorName: "",                  // Glaeubigeor-Name
    creditorStreet: null,              // Glaeubigeor-Strasse (optional)
    creditorCity: null,                // Glaeubigeor-Stadt (optional)
    creditorCountry: null,             // Glaeubigeor-Land (optional)
    creditorIBAN: "",                  // Glaeubigeor-IBAN
    creditorBIC: "",                   // Glaeubigeor-BIC
    debtorId: "",                      // Schuldner-ID
    debtorName: "",                    // Schuldner-Name (nur Ueberweisung)
    debtorStreet: null,                // Schuldner-Strasse (optional)
    debtorCity: null,                  // Schuldner-Stadt (optional)
    debtorCountry: null,               // Schuldner-Land (optional)
    debtorIBAN: "",                    // Schuldner-IBAN
    debtorBIC: "",                     // Schuldner-BIC
    instructionPriority: "NORM",       // Prioritaet (NORM oder HIGH)

    /**
     * Gibt die Anzahl der Transaktionen in diesem Zahlungsblock zurueck.
     * @returns {number} Anzahl Transaktionen
     */
    get transactionCount() {
      return this._payments.length
    },

    /**
     * Berechnet die Kontrollsumme (Gesamtbetrag) aller Transaktionen.
     */
    normalize: function () {
      var t = 0;
      for (var n = 0, e = this._payments.length; n < e; ++n) {
        t += this._payments[n].amount
      }
      this.controlSum = t
    },

    /**
     * Fuegt eine Transaktion zum Zahlungsblock hinzu.
     * Die Transaktions-ID wird automatisch mit der PaymentInfo-ID prefixed.
     *
     * @param {Object} t - Transaktions-Objekt (erstellt via createTransaction())
     */
    addTransaction: function (t) {
      // Hinweis: instanceof-Pruefung wurde entfernt fuer bessere Kompatibilitaet
      if (t.id) {
        t.id = this.id + i + t.id
      } else {
        t.id = this.id + i + this._payments.length
      }
      this._payments.push(t)
    },

    /**
     * Erstellt eine neue Transaktion mit dem pain-Format des Zahlungsblocks.
     * @returns {Object} Neues Transaktions-Objekt
     */
    createTransaction: function () {
      return new y(this._painFormat)
    },

    /**
     * Validiert alle Pflichtfelder des Zahlungsblocks.
     * Wird automatisch vor der XML-Erzeugung aufgerufen (wenn Validierungen aktiv).
     *
     * Prueft je nach Zahlungsmethode:
     *   - localInstrumentation: Muss CORE, COR1 oder B2B sein
     *   - sequenceType: Muss FRST, RCUR, OOFF oder FNAL sein
     *   - collectionDate/requestedExecutionDate: Muss gueltiges Datum sein
     *   - creditorId/debtorId: Glaeubigeor-ID-Checksumme (nur Lastschrift)
     *   - Name, IBAN, BIC: Format- und Laengenvalidierung
     *   - BIC/IBAN-Laenderabgleich: Laendercode muss uebereinstimmen
     *   - Mindestens eine Transaktion muss vorhanden sein
     *
     * @throws {Error} Bei unguelitgen Werten
     */
    validate: function () {
      // Dynamischer Feldname-Prefix: "creditor" bei Lastschrift, "debtor" bei Ueberweisung
      var t = this.method === f.DirectDebit ? "creditor" : "debtor";

      B(this.localInstrumentation, ["CORE", "COR1", "B2B"], "localInstrumentation");
      B(this.sequenceType, ["FRST", "RCUR", "OOFF", "FNAL"], "sequenceType");

      // Datumsvalidierung: Je nach Typ unterschiedliches Datum pruefen
      if (this.method === f.DirectDebit) {
        T(this.collectionDate, "collectionDate")
      } else {
        T(this.requestedExecutionDate, "requestedExecutionDate")
      }

      // Glaeubigeor-ID nur bei Lastschriften validieren
      // (bei Ueberweisungen gibt es keine Glaeubigeor-ID)
      if (this.method === f.DirectDebit) {
        x(this[t + "Id"], t + "Id");
      }

      // Name, Adresse und Bankdaten validieren
      A(this[t + "Name"], null, 70, t + "Name");
      A(this[t + "Street"], null, 70, t + "Street");
      A(this[t + "City"], null, 70, t + "City");
      A(this[t + "Country"], null, 2, t + "Country");
      E(this[t + "IBAN"], t + "IBAN");
      A(this[t + "BIC"], [0, 8, 11], t + "BIC");

      // Laendercode-Abgleich: BIC-Land (Zeichen 5-6) muss mit IBAN-Land (Zeichen 1-2) uebereinstimmen
      var n = this[t + "BIC"].length === 0 || this[t + "BIC"].substr(4, 2) === this[t + "IBAN"].substr(0, 2);
      _(n, "country mismatch in BIC/IBAN");

      // Mindestens eine Transaktion erforderlich
      A(this._payments.length, 1, null, "_payments")
    },

    /**
     * Erzeugt das <PmtInf> XML-Element mit allen Transaktionen.
     *
     * @param {Document} t - XML-Dokument fuer createElement-Aufrufe
     * @returns {Element} <PmtInf> XML-Element
     */
    toXML: function (t) {
      // Validierung ausfuehren wenn aktiviert
      if (c) {
        this.validate()
      }

      var n = M(t, true, false);   // Helper: Nur Element erstellen (ohne Text)
      var e = M(t, true, true);    // Helper: Element erstellen + Text setzen
      var r = t.createElementNS(t.documentElement.namespaceURI, "PmtInf");

      // === Basis-Informationen ===
      e(r, "PmtInfId", this.id);               // Zahlungsblock-ID
      e(r, "PmtMtd", this.method);             // DD oder TRF

      // Bei neueren Formaten (Version 3): BatchBooking, Anzahl und Summe im PmtInf
      if (l(this._painFormat) === 3) {
        e(r, "BtchBookg", this.batchBooking.toString());
        e(r, "NbOfTxs", this.transactionCount);
        e(r, "CtrlSum", this.controlSum.toFixed(2))
      }

      // === Zahlungstyp-Informationen (PmtTpInf) ===
      var i = n(r, "PmtTpInf");
      e(i, "SvcLvl", "Cd", "SEPA");            // Service Level = SEPA

      if (this.method === f.DirectDebit) {
        // Lastschrift-spezifisch:
        e(i, "LclInstrm", "Cd", this.localInstrumentation);  // CORE/COR1/B2B
        e(i, "SeqTp", this.sequenceType);                      // FRST/RCUR/OOFF/FNAL
        // Einzugsdatum (nur Lastschrift) - Format: YYYY-MM-DD
        e(r, "ReqdColltnDt", this.collectionDate.toISOString().substr(0, 10))
      } else {
        // Ueberweisung: Ausfuehrungsdatum - Format: YYYY-MM-DD
        e(r, "ReqdExctnDt", this.requestedExecutionDate.toISOString().substr(0, 10))
      }

      // === Glaeubigeor/Schuldner-Daten ===
      // Bei Lastschrift: Glaeubigeor (Cdtr) = wer das Geld einzieht
      // Bei Ueberweisung: Schuldner (Dbtr) = wer das Geld sendet
      var o = this.method === f.DirectDebit ? "creditor" : "debtor";
      var a = this.method === f.DirectDebit ? "Cdtr" : "Dbtr";

      var s = n(r, a);                                    // <Cdtr> oder <Dbtr>
      e(s, "Nm", this[o + "Name"]);                       // Name

      // Optionale Adressdaten (nur wenn alle drei Felder gesetzt)
      if (this[o + "Street"] && this[o + "City"] && this[o + "Country"]) {
        var d = n(s, "PstlAdr");                           // Postadresse
        e(d, "Ctry", this[o + "Country"]);                 // Land (ISO 3166, z.B. "DE")
        e(d, "AdrLine", this[o + "Street"]);               // Strasse
        e(d, "AdrLine", this[o + "City"])                  // Stadt
      }

      // Konto (IBAN)
      e(r, a + "Acct", "Id", "IBAN", this[o + "IBAN"]);

      // Bank (BIC) - wenn vorhanden, sonst "NOTPROVIDED"
      if (this[o + "BIC"]) {
        e(r, a + "Agt", "FinInstnId", "BIC", this[o + "BIC"])
      } else {
        e(r, a + "Agt", "FinInstnId", "Othr", "Id", "NOTPROVIDED")
      }

      // Gebuehrenregelung: SLEV = Service Level (SEPA-Standard)
      e(r, "ChrgBr", "SLEV");

      // === Glaeubigeor-Schema-Identifikation (nur Lastschrift) ===
      // Enthaelt die Glaeubigeor-ID (z.B. DE98ZZZ09999999999)
      if (this.method === f.DirectDebit) {
        var u = n(r, "CdtrSchmeId", "Id", "PrvtId", "Othr");
        e(u, "Id", this.creditorId);
        e(u, "SchmeNm", "Prtry", "SEPA")
      }

      // === Transaktionen einfuegen ===
      for (var h = 0, m = this._payments.length; h < m; ++h) {
        r.appendChild(this._payments[h].toXML(t))
      }
      return r
    },

    toString: function () {
      return L(this.toXML())
    }
  };

  // ============================================================
  // Transaktions-Typen (XML-Element-Namen)
  // ============================================================

  /** XML-Element-Namen fuer Transaktionen */
  var I = {
    DirectDebit: "DrctDbtTxInf",   // Lastschrift-Transaktion
    Transfer: "CdtTrfTxInf"        // Ueberweisungs-Transaktion
  };

  // ============================================================
  // Transaction-Klasse (y) - Einzelne SEPA-Transaktion
  // ============================================================

  /**
   * Repraesentiert eine einzelne SEPA-Transaktion (Lastschrift oder Ueberweisung).
   *
   * Bei Lastschrift (DrctDbtTxInf):
   *   - Schuldner (Debtor) = von wem Geld eingezogen wird
   *   - Enthaelt Mandatsinformationen (mandateId, mandateSignatureDate)
   *
   * Bei Ueberweisung (CdtTrfTxInf):
   *   - Glaeubigeor (Creditor) = an wen Geld ueberwiesen wird
   *   - Keine Mandatsinformationen erforderlich
   *
   * @constructor
   * @param {string} t - Pain-Format-String
   */
  function y(t) {
    this._painFormat = t;
    // Transaktionstyp aus Format ableiten
    this._type = t.indexOf("pain.001") === 0 ? I.Transfer : I.DirectDebit
  }

  /** Statischer Zugriff auf Transaktions-Typen */
  y.TransactionTypes = I;

  y.prototype = {
    _type: I.DirectDebit,
    id: "",                         // InstrId - Instruktions-ID
    end2endId: "",                  // EndToEndId - Ende-zu-Ende-Referenz
    currency: "EUR",                // Ccy - Waehrung (Standard: EUR)
    amount: 0,                      // InstdAmt - Betrag in EUR
    purposeCode: null,              // Purp/Cd - Verwendungszweck-Code (optional)
    mandateId: "",                  // MndtId - Mandatsreferenz (nur Lastschrift)
    mandateSignatureDate: null,     // DtOfSgntr - Mandats-Unterschriftsdatum (nur Lastschrift)
    debtorName: "",                 // Dbtr/Nm - Schuldner-Name
    debtorStreet: null,             // Dbtr/PstlAdr/AdrLine - Strasse (optional)
    debtorCity: null,               // Dbtr/PstlAdr/AdrLine - Stadt (optional)
    debtorCountry: null,            // Dbtr/PstlAdr/Ctry - Land (optional)
    debtorIBAN: "",                 // DbtrAcct/Id/IBAN
    debtorBIC: "",                  // DbtrAgt/FinInstnId/BIC
    remittanceInfo: "",             // RmtInf/Ustrd - Verwendungszweck (max. 140 Zeichen)
    creditorName: "",               // Cdtr/Nm - Glaeubigeor-Name
    creditorStreet: null,           // Cdtr/PstlAdr/AdrLine - Strasse (optional)
    creditorCity: null,             // Cdtr/PstlAdr/AdrLine - Stadt (optional)
    creditorCountry: null,          // Cdtr/PstlAdr/Ctry - Land (optional)
    creditorIBAN: "",               // CdtrAcct/Id/IBAN
    creditorBIC: "",                // CdtrAgt/FinInstnId/BIC

    /**
     * Validiert alle Pflichtfelder der Transaktion.
     *
     * Prueft:
     *   - end2endId: SEPA-Zeichensatz (alphanumerisch + Sonderzeichen, max. 35 Zeichen)
     *   - amount: 0.01 - 999.999.999,99 EUR, max. 2 Dezimalstellen
     *   - purposeCode: 1-4 Zeichen (optional)
     *   - mandateId + mandateSignatureDate: Nur bei Lastschrift erforderlich
     *   - Name, IBAN, BIC: Format- und Laengenvalidierung
     *   - BIC/IBAN-Laenderabgleich
     *   - remittanceInfo: Max. 140 Zeichen
     *
     * @throws {Error} Bei ungueltigen Werten
     */
    validate: function () {
      // Dynamischer Feldname: "creditor" bei Ueberweisung, "debtor" bei Lastschrift
      var t = this._type === I.Transfer ? "creditor" : "debtor";

      w(this.end2endId, "end2endId");                                    // SEPA-Zeichensatz Typ 1
      N(this.amount, .01, 999999999.99, "amount");                       // Betragsbereich
      _(this.amount == this.amount.toFixed(2), "amount has too many fractional digits");  // Max. 2 Dezimalen
      A(this.purposeCode, 1, 4, "purposeCode");                         // Optionaler Zweck-Code

      // Mandatsinformationen nur bei Lastschriften erforderlich
      if (this._type === I.DirectDebit) {
        F(this.mandateId, "mandateId");                                  // SEPA-Zeichensatz Typ 2
        T(this.mandateSignatureDate, "mandateSignatureDate");            // Gueltiges Datum
      }

      // Empfaenger/Schuldner-Daten validieren
      A(this[t + "Name"], null, 70, t + "Name");
      A(this[t + "Street"], null, 70, t + "Street");
      A(this[t + "City"], null, 70, t + "City");
      A(this[t + "Country"], null, 2, t + "Country");
      E(this[t + "IBAN"], t + "IBAN");
      B(this[t + "BIC"].length, [0, 8, 11], t + "BIC");

      // BIC/IBAN-Laenderabgleich
      var n = this[t + "BIC"].length === 0 || this[t + "BIC"].substr(4, 2) === this[t + "IBAN"].substr(0, 2);
      _(n, "country mismatch in BIC/IBAN");

      // Verwendungszweck max. 140 Zeichen
      A(this.remittanceInfo, null, 140, "remittanceInfo")
    },

    /**
     * Erzeugt das XML-Element fuer diese Transaktion.
     *
     * Lastschrift-XML (<DrctDbtTxInf>):
     *   <PmtId>          - Zahlungsidentifikation (InstrId, EndToEndId)
     *   <InstdAmt>       - Betrag mit Waehrungsattribut
     *   <DrctDbtTx>      - Lastschrift-spezifisch (Mandat)
     *   <DbtrAgt>        - Bank des Schuldners
     *   <Dbtr>           - Schuldner (Name, Adresse)
     *   <DbtrAcct>       - Konto des Schuldners (IBAN)
     *   <RmtInf>         - Verwendungszweck
     *
     * Ueberweisungs-XML (<CdtTrfTxInf>):
     *   <PmtId>          - Zahlungsidentifikation
     *   <Amt><InstdAmt>  - Betrag (verschachtelt)
     *   <CdtrAgt>        - Bank des Empfaengers
     *   <Cdtr>           - Empfaenger (Name, Adresse)
     *   <CdtrAcct>       - Konto des Empfaengers (IBAN)
     *   <RmtInf>         - Verwendungszweck
     *
     * @param {Document} t - XML-Dokument fuer createElement-Aufrufe
     * @returns {Element} Transaktions-XML-Element
     */
    toXML: function (t) {
      // Validierung ausfuehren wenn aktiviert
      if (c) {
        this.validate()
      }

      // Dynamische Feld- und Element-Namen je nach Transaktionstyp
      var n = this._type === I.Transfer ? "creditor" : "debtor";
      var e = this._type === I.Transfer ? "Cdtr" : "Dbtr";

      var r = M(t, true, false);   // Helper: Element erstellen (ohne Text)
      var i = M(t, false, true);   // Helper: Element nur erstellen wenn Wert vorhanden
      var o = M(t, true, true);    // Helper: Element erstellen + Text setzen

      // Root-Element der Transaktion (<DrctDbtTxInf> oder <CdtTrfTxInf>)
      var a = t.createElementNS(t.documentElement.namespaceURI, this._type);

      // === Zahlungsidentifikation ===
      var s = r(a, "PmtId");
      o(s, "InstrId", this.id);                // Instruktions-ID
      o(s, "EndToEndId", this.end2endId);      // Ende-zu-Ende-Referenz

      if (this._type === I.DirectDebit) {
        // === Lastschrift-spezifisch ===
        // Betrag direkt als Kind-Element (nicht verschachtelt)
        o(a, "InstdAmt", this.amount.toFixed(2)).setAttribute("Ccy", this.currency);

        // Mandatsinformationen
        var d = r(a, "DrctDbtTx", "MndtRltdInf");
        o(d, "MndtId", this.mandateId);                                          // Mandatsreferenz
        o(d, "DtOfSgntr", this.mandateSignatureDate.toISOString().substr(0, 10)); // Unterschriftsdatum

        // Mandatsaenderung (Amendment) - optional
        if (this.ammendment) {
          o(d, "AmdmntInd", "true");
          o(d, "AmdmnInfDtls", this.ammendment)
        } else {
          o(d, "AmdmntInd", "false")
        }
      } else {
        // === Ueberweisungs-spezifisch ===
        // Betrag verschachtelt: <Amt><InstdAmt Ccy="EUR">...</InstdAmt></Amt>
        o(a, "Amt", "InstdAmt", this.amount.toFixed(2)).setAttribute("Ccy", this.currency)
      }

      // === Bank des Empfaengers/Schuldners ===
      if (this[n + "BIC"]) {
        o(a, e + "Agt", "FinInstnId", "BIC", this[n + "BIC"])
      } else {
        // Wenn kein BIC angegeben, "NOTPROVIDED" setzen (seit 2016 optional im SEPA-Raum)
        o(a, e + "Agt", "FinInstnId", "Othr", "Id", "NOTPROVIDED")
      }

      // === Empfaenger/Schuldner-Daten ===
      var u = r(a, e);                          // <Cdtr> oder <Dbtr>
      o(u, "Nm", this[n + "Name"]);             // Name

      // Optionale Adressdaten
      if (this[n + "Street"] && this[n + "City"] && this[n + "Country"]) {
        var h = r(u, "PstlAdr");
        o(h, "Ctry", this.debtorCountry);
        o(h, "AdrLine", this.debtorStreet);
        o(h, "AdrLine", this.debtorCity)
      }

      // Konto (IBAN)
      o(a, e + "Acct", "Id", "IBAN", this[n + "IBAN"]);

      // Verwendungszweck (unstrukturiert)
      o(a, "RmtInf", "Ustrd", this.remittanceInfo);

      // Optionaler Verwendungszweck-Code (z.B. SALA = Gehalt, SUPP = Lieferant)
      i(a, "Purp", "Cd", this.purposeCode);

      return a
    }
  };

  // ============================================================
  // IBAN- und Glaeubigeor-ID-Validierung (Mod-97 Pruefziffer)
  // ============================================================

  /**
   * Konvertiert einen alphanumerischen String in eine rein numerische Darstellung.
   * Buchstaben werden gemaess ISO 13616 umgewandelt: A=10, B=11, ..., Z=35
   *
   * Wird fuer die Mod-97-Pruefzifferberechnung bei IBAN und Glaeubigeor-ID benoetigt.
   *
   * @param {string} t - Alphanumerischer String
   * @returns {string} Numerische Darstellung
   */
  function C(t) {
    var n = "";
    for (var e = 0, r = t.length; e < r; ++e) {
      var i = t.charCodeAt(e);
      if (i >= 65 && i <= 90) {
        // Grossbuchstaben: A(65)=10, B(66)=11, ..., Z(90)=35
        n += (i - 55).toString()
      } else if (i >= 97 && i <= 122) {
        // Kleinbuchstaben: a(97)=10, b(98)=11, ..., z(122)=35
        n += (i - 87).toString()
      } else if (i >= 48 && i <= 57) {
        // Ziffern bleiben unveraendert
        n += t[e]
      }
    }
    return n
  }

  /**
   * Berechnet Modulo 97 einer langen Zahl (als String dargestellt).
   * Verwendet schrittweise Berechnung, um Integer-Ueberlauf zu vermeiden.
   *
   * @param {string} t - Numerischer String
   * @returns {number} Rest bei Division durch 97
   */
  function v(t) {
    var n = 0;
    for (var e = 0, r = t.length; e < r; ++e) {
      n = (n * 10 + parseInt(t[e], 10)) % 97
    }
    return n
  }

  /**
   * Validiert eine IBAN mittels Mod-97-Pruefziffer (ISO 13616).
   *
   * Algorithmus:
   *   1. Die ersten 4 Zeichen (Laendercode + Pruefziffer) ans Ende verschieben
   *   2. Buchstaben in Zahlen umwandeln (A=10, B=11, ...)
   *   3. Mod 97 berechnen - Ergebnis muss 1 sein
   *
   * @param {string} t - IBAN (z.B. "DE89370400440532013000")
   * @returns {boolean} true wenn IBAN gueltig
   */
  function g(t) {
    var n = t.substr(4) + t.substr(0, 4);  // Ersten 4 Zeichen ans Ende
    return v(C(n)) === 1                     // Mod 97 muss 1 ergeben
  }

  /**
   * Berechnet die korrekte Pruefziffer fuer eine IBAN.
   *
   * @param {string} t - IBAN mit Platzhalter-Pruefziffer
   * @returns {string} IBAN mit korrekter Pruefziffer
   */
  function b(t) {
    var n = t.substr(4) + t.substr(0, 2) + "00";
    var e = v(C(n));
    return t.substr(0, 2) + ("0" + (98 - e)).substr(-2, 2) + t.substr(4)
  }

  /**
   * Validiert eine Glaeubigeor-Identifikationsnummer (Creditor ID).
   *
   * Format: z.B. DE98ZZZ09999999999
   *   - Zeichen 1-2: Laendercode (z.B. "DE")
   *   - Zeichen 3-4: Pruefziffer
   *   - Zeichen 5-7: Geschaeftsbereichskennung (frei waehlbar, oft "ZZZ")
   *   - Zeichen 8+: Nationale Kennung
   *
   * Algorithmus: Wie IBAN, aber Zeichen 5-7 werden uebersprungen
   *   1. Ab Zeichen 8 + erste 4 Zeichen → Mod 97 == 1
   *
   * @param {string} t - Glaeubigeor-ID
   * @returns {boolean} true wenn gueltig
   */
  function D(t) {
    var n = t.substr(7) + t.substr(0, 4);  // Nationale Kennung + Laendercode+Pruefziffer
    return v(C(n)) === 1
  }

  /**
   * Berechnet die korrekte Pruefziffer fuer eine Glaeubigeor-ID.
   *
   * @param {string} t - Glaeubigeor-ID mit Platzhalter-Pruefziffer
   * @returns {string} Glaeubigeor-ID mit korrekter Pruefziffer
   */
  function S(t) {
    var n = t.substr(7) + t.substr(0, 2) + "00";
    var e = v(C(n));
    return t.substr(0, 2) + ("0" + (98 - e)).substr(-2, 2) + t.substr(4)
  }

  // ============================================================
  // Validierungsfunktionen
  // ============================================================

  /**
   * Prueft eine Bedingung und wirft einen Fehler wenn falsch (Assertion).
   * @param {boolean} t - Bedingung
   * @param {string} n - Fehlermeldung
   * @throws {Error} Wenn Bedingung falsch
   */
  function _(t, n) {
    if (!t) {
      throw new Error(n)
    }
  }

  /**
   * Prueft ob ein Wert in einer erlaubten Liste enthalten ist.
   * @param {*} t - Zu pruefender Wert
   * @param {Array} n - Liste erlaubter Werte
   * @param {string} e - Feldname fuer Fehlermeldung
   * @throws {Error} Wenn Wert nicht in der Liste
   */
  function B(t, n, e) {
    if (n.indexOf(t) < 0) {
      throw new Error(e + " must have any value of: " + n.join(" ") + "(found: " + t + ")")
    }
  }

  /**
   * Prueft die Stringlaenge eines Wertes (Minimum und/oder Maximum).
   * Null-Werte werden uebersprungen (optionale Felder).
   *
   * @param {*} t - Zu pruefender Wert (oder Array mit .length)
   * @param {number|null} n - Minimale Laenge (null = kein Minimum)
   * @param {number|null} e - Maximale Laenge (null = kein Maximum)
   * @param {string} r - Feldname fuer Fehlermeldung
   * @throws {Error} Wenn Laenge ausserhalb des Bereichs
   */
  function A(t, n, e, r) {
    if (n !== null && t && t.length < n || e !== null && t && t.length > e) {
      throw new Error(r + " has invalid string length, expected " + n + " < " + t + " < " + e)
    }
  }

  /**
   * Prueft ob ein numerischer Wert im erlaubten Bereich liegt.
   * @param {number} t - Zu pruefender Wert
   * @param {number} n - Minimum (inklusive)
   * @param {number} e - Maximum (inklusive)
   * @param {string} r - Feldname fuer Fehlermeldung
   * @throws {Error} Wenn Wert ausserhalb des Bereichs
   */
  function N(t, n, e, r) {
    if (t < n || t > e) {
      throw new Error(r + " does not match range " + n + " < " + t + " < " + e)
    }
  }

  /**
   * Validiert eine IBAN mittels Mod-97-Pruefziffer.
   * @param {string} t - IBAN
   * @param {string} n - Feldname fuer Fehlermeldung
   * @throws {Error} Wenn IBAN ungueltig
   */
  function E(t, n) {
    if (!g(t)) {
      throw new Error(n + ' has invalid IBAN "' + t + '"')
    }
  }

  /**
   * Validiert eine Glaeubigeor-ID mittels Mod-97-Pruefziffer.
   * @param {string} t - Glaeubigeor-ID
   * @param {string} n - Feldname fuer Fehlermeldung
   * @throws {Error} Wenn ID ungueltig
   */
  function x(t, n) {
    if (!D(t)) {
      throw new Error(n + ' is invalid "' + t + '"')
    }
  }

  /**
   * Prueft ob ein Date-Objekt gueltig ist (nicht null, nicht NaN).
   * @param {Date} t - Datum
   * @param {string} n - Feldname fuer Fehlermeldung
   * @throws {Error} Wenn Datum ungueltig
   */
  function T(t, n) {
    if (!t || isNaN(t.getTime())) {
      throw new Error(n + " has invalid date " + t)
    }
  }

  /**
   * Prueft ob eine Ende-zu-Ende-ID dem SEPA-Zeichensatz Typ 1 entspricht.
   * Erlaubt: A-Z, a-z, 0-9, +, ?, /, -, :, (, ), ., ,, ', Leerzeichen
   * Max. 35 Zeichen.
   *
   * Fehler werden nur in die Konsole geloggt (nicht geworfen),
   * da die End2EndId in manchen Systemen flexibler gehandhabt wird.
   *
   * @param {string} t - Ende-zu-Ende-ID
   * @param {string} n - Feldname fuer Fehlermeldung
   */
  function w(t, n) {
    try {
      if (t && !t.match(/([A-Za-z0-9]|[+|?|/|\-|:|(|)|.|,|'| ]){1,35}/)) {
        throw new Error(n + " doesn't match sepa id charset type 1 (found: " + '"' + t + '")')
      }
    } catch (e) {
      console.error(e);
    }
  }

  /**
   * Prueft ob eine Mandatsreferenz dem SEPA-Zeichensatz Typ 2 entspricht.
   * Wie Typ 1, aber ohne Leerzeichen.
   * Erlaubt: A-Z, a-z, 0-9, +, ?, /, -, :, (, ), ., ,, '
   * Max. 35 Zeichen.
   *
   * @param {string} t - Mandatsreferenz
   * @param {string} n - Feldname fuer Fehlermeldung
   * @throws {Error} Wenn Zeichensatz nicht uebereinstimmt
   */
  function F(t, n) {
    if (t && !t.match(/([A-Za-z0-9]|[+|?|/|\-|:|(|)|.|,|']){1,35}/)) {
      throw new Error(n + " doesn't match sepa id charset type 2 (found: " + '"' + t + '")')
    }
  }

  // ============================================================
  // XML-DOM-Hilfsfunktionen (Browser/Node.js kompatibel)
  // ============================================================

  /**
   * Erstellt ein neues XML-Dokument mit dem gegebenen Namespace und Root-Element.
   * Verwendet im Browser document.implementation, in Node.js die xmldom-Bibliothek.
   *
   * @param {string} t - XML-Namespace
   * @param {string} n - Root-Element-Name
   * @returns {Document} Neues XML-Dokument
   */
  function O(t, n) {
    if (typeof document !== "undefined" && typeof document.implementation !== "undefined") {
      // Browser-Umgebung: Nativer DOM-Support
      return document.implementation.createDocument(t, n)
    } else {
      // Node.js-Umgebung: xmldom-Bibliothek verwenden
      var e = require("xmldom").DOMImplementation;
      return (new e).createDocument(t, n)
    }
  }

  /**
   * Serialisiert ein XML-Dokument oder Element zu einem String.
   * Verwendet im Browser window.XMLSerializer, in Node.js xmldom.XMLSerializer.
   *
   * @param {Document|Element} t - XML-Dokument oder Element
   * @returns {string} XML-String
   */
  function L(t) {
    var n;
    if (typeof window === "undefined") {
      // Node.js-Umgebung
      var e = require("xmldom").XMLSerializer;
      n = new e
    } else {
      // Browser-Umgebung
      n = new window.XMLSerializer
    }
    return n.serializeToString(t)
  }

  /**
   * Factory-Funktion: Erstellt einen Helper zum Erzeugen verschachtelter XML-Elemente.
   *
   * Dies ist die zentrale Funktion fuer die XML-Erzeugung. Sie gibt eine Closure zurueck,
   * die mit variablen Argumenten aufgerufen werden kann:
   *
   * Aufruf-Muster:
   *   helper(parent, "Tag1", "Tag2", ..., textValue)
   *
   * Erzeugt verschachtelte Elemente und setzt optional den Textinhalt des innersten Elements.
   *
   * Parameter der Factory:
   * @param {Document} i - XML-Dokument (fuer createElementNS)
   * @param {boolean} o - true = immer erstellen, false = nur wenn Wert vorhanden (optional)
   * @param {boolean} a - true = letztes Argument ist Textinhalt, false = alle sind Elemente
   *
   * @returns {Function} Helper-Funktion(parentElement, tag1, tag2, ..., [textContent])
   */
  function M(i, o, a) {
    return function () {
      var t = arguments[0];                              // Parent-Element
      var n = a && arguments[arguments.length - 1];       // Textinhalt (letztes Argument wenn a=true)
      var e = a ? arguments.length - 1 : arguments.length; // Anzahl Element-Tags

      // Nur erstellen wenn: immer erstellen (o=true) ODER Wert vorhanden
      if (o || n || n === 0) {
        // Verschachtelte Elemente erstellen: arguments[1] > arguments[2] > ...
        for (var r = 1; r < e; ++r) {
          t = t.appendChild(i.createElementNS(i.documentElement.namespaceURI, arguments[r]))
        }
        // Textinhalt setzen wenn gewuenscht
        if (a) {
          t.textContent = n
        }
        return t
      } else {
        return null
      }
    }
  }

  // ============================================================
  // Oeffentliche API (UMD-Export)
  // ============================================================
  // Im Browser: window.SEPA = { Document, validateIBAN, ... }
  // In Node.js: exports = { Document, validateIBAN, ... }

  t.Document = h;                   // SEPA.Document - Hauptklasse
  t.validateIBAN = g;               // SEPA.validateIBAN(iban) → boolean
  t.checksumIBAN = b;               // SEPA.checksumIBAN(iban) → korrigierte IBAN
  t.validateCreditorID = D;         // SEPA.validateCreditorID(id) → boolean
  t.checksumCreditorID = S;         // SEPA.checksumCreditorID(id) → korrigierte ID
  t.setIDSeparator = o;             // SEPA.setIDSeparator(sep) → void
  t.enableValidations = d           // SEPA.enableValidations(flag) → void

})(typeof exports === "undefined" ? this.SEPA = {} : exports);
